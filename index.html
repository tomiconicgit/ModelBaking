<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <title>PWA 3D Editor</title>

  <link rel="manifest" href='data:application/manifest+json,{
    "name":"PWA 3D Editor",
    "short_name":"3D Editor",
    "start_url":".",
    "display":"standalone",
    "background_color":"#101318",
    "theme_color":"#101318",
    "icons":[
      {"src":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABS3GwHAAAAaklEQVR4nO3BMQEAAADCoPVPbQ0PoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACeDc1wAAGaT44gAAAAAElFTSuQmCC","sizes":"192x192","type":"image/png"}
    ]
  }' />

  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="3D Editor" />
  <meta name="theme-color" content="#101318" />

  <style>
    :root {
      --bg:#101318; --panel-bg:#161a21;
      --fg:#e6eef6; --fg-light:#8899aa; --fg-disabled:#556677;
      --primary:#0aa2ff; --primary-light:#33b3ff;
      --accent:#ff4757; --accent-light:#ff6b81;
      --border-color:#2a2f36; --border-color-light:#4a4f56;
      --viewer-height: clamp(260px, 55vh, 70vh);
    }
    html,body{height:100%;margin:0;overflow:hidden}
    body{
      background:var(--bg);color:var(--fg);
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
      -webkit-font-smoothing:antialiased;font-size:16px;
    }
    #app{
      display:flex;flex-direction:column;height:100vh;height:100dvh;
      padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    #viewer3d{height:var(--viewer-height);flex-shrink:0;position:relative}
    #viewer3d canvas{display:block;width:100%;height:100%}
    #hud{
      position:absolute;left:10px;top:10px;z-index:5;
      background:rgba(0,0,0,.55);border:1px solid #2a2f36;border-radius:8px;
      padding:6px 8px;font:12px/1.3 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;color:#cfe8ff;
      pointer-events:none
    }
    #panel-container{flex-grow:1;background:var(--panel-bg);border-top:1px solid var(--border-color);display:flex;flex-direction:column;overflow:hidden;}
    #bottom-navbar{display:flex;border-bottom:1px solid var(--border-color);flex-shrink:0;overflow-x:auto;}
    .nav-btn{padding:12px 16px;border:none;background:none;color:var(--fg-light);cursor:pointer;font-size:.9rem;font-weight:500;border-bottom:2px solid transparent;transition:color .2s,border-color .2s;-webkit-tap-highlight-color:transparent;white-space:nowrap;}
    .nav-btn:hover{color:var(--fg)} .nav-btn.active{color:var(--primary);border-bottom-color:var(--primary)}
    #panel-content{flex-grow:1;position:relative;overflow-y:auto;}
    .panel{padding:1rem;min-height:100%} .panel.hidden{display:none}
    .hidden{display:none!important}
    .visually-hidden-input{position:fixed;left:-9999px;width:1px;height:1px;opacity:0}

    .button{background:var(--primary);color:#fff;border:none;border-radius:8px;padding:10px 16px;font-size:.9rem;font-weight:500;cursor:pointer;transition:background .2s;display:inline-flex;align-items:center;gap:8px}
    .button:hover{background:var(--primary-light)} .button:disabled{background:#333;color:#777;cursor:not-allowed}
    .button.accent{background:var(--accent)} .button.accent:hover{background:var(--accent-light)}
    .button.ghost{background:transparent;border:1px solid var(--border-color);color:var(--fg)}
    .button.ghost:hover{background:var(--border-color)}
    .button-group{display:flex;flex-wrap:wrap;gap:.75rem}
    .status-text{text-align:center;color:var(--fg-light);padding:2rem 0;width:100%}
    .form-group{margin-bottom:1rem}
    .form-group label{display:block;margin-bottom:.5rem;font-size:.85rem;color:var(--fg-light)}
    .form-group select,.form-group input[type=text], .form-group input[type=number]{width:100%;background:#2a2f36;color:var(--fg);border:1px solid var(--border-color);border-radius:6px;padding:10px;font-size:.9rem;box-sizing:border-box}
    .form-row{display:grid;grid-template-columns:repeat(3,1fr);gap:.75rem}

    #tabs-list{display:grid;gap:1rem;grid-template-columns:repeat(auto-fill, minmax(280px,1fr))}
    .tab-card{background:#1e222a;border:1px solid var(--border-color);border-radius:8px;padding:1rem}
    .tab-card.active{border-color:var(--primary);box-shadow:0 0 10px rgba(0,153,255,.3)}
    .tab-card-header{display:flex;justify-content:space-between;align-items:flex-start;gap:1rem;margin-bottom:1rem}
    .tab-card-header h3{margin:0;font-size:1rem;word-break:break-all}
    .tab-card-info{font-size:.8rem;color:var(--fg-light);display:grid;grid-template-columns:auto 1fr;gap:4px 12px}
    .tab-card-actions{margin-top:1rem;display:flex;gap:.5rem}

    .list-item{display:flex;align-items:center;gap:10px;padding:8px;border-radius:6px;transition:background .2s}
    .list-item:hover{background:#2a2f36}
    .list-item-label{flex-grow:1}
    .list-item-actions{display:flex;gap:5px}
    .small-btn{padding:4px;background:none;border:1px solid var(--border-color-light);color:var(--fg-light);border-radius:4px;cursor:pointer;display:flex;align-items:center}
    .small-btn:hover{background:var(--border-color-light);color:var(--fg)}
    #texture-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:1rem}
    .texture-slot{text-align:center} .texture-slot .button{width:100%;font-size:.8rem}

    .modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.7);backdrop-filter:blur(4px);display:flex;align-items:center;justify-content:center;z-index:1000}
    .modal-overlay.hidden{display:none}
    .modal-content{background:var(--panel-bg);border:1px solid var(--border-color);border-radius:12px;width:clamp(300px,90vw,500px);max-height:85vh;display:flex;flex-direction:column;box-shadow:0 10px 30px rgba(0,0,0,.3)}
    .modal-header{padding:1rem;border-bottom:1px solid var(--border-color);font-size:1.2rem;font-weight:500}
    .modal-body{flex-grow:1;overflow-y:auto;padding:1rem}
    .modal-footer{padding:1rem;border-top:1px solid var(--border-color);display:flex;justify-content:flex-end;gap:.5rem;flex-wrap:wrap}

    /* Tiny on-screen debugger */
    #dbg{position:fixed;right:8px;bottom:8px;z-index:1200}
    #dbg button{opacity:.6}
    #dbglog{position:fixed;inset:auto 8px 48px auto;right:8px;bottom:48px;width:min(90vw,520px);max-height:40vh;overflow:auto;background:#000c;border:1px solid #333;padding:.5rem;border-radius:8px;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;font-size:12px;color:#9fe}
    #dbglog.hidden{display:none}

    /* Slider rows with nudge buttons */
    .slider-row{
      display:grid;
      grid-template-columns:28px 24px 1fr 90px 24px;
      gap:.6rem; align-items:center; margin-bottom:.5rem;
    }
    .slider-row label{
      text-align:center; font-weight:600; color:var(--fg-light);
    }
    .slider-row input[type="range"]{ width:100%; }
    .nudge{height:28px;width:24px;border:1px solid var(--border-color-light);background:#1c2128;color:var(--fg);border-radius:6px;cursor:pointer}
    .nudge:active{transform:translateY(1px)}
    .num{width:100%;background:#2a2f36;color:var(--fg);border:1px solid var(--border-color);border-radius:6px;padding:8px 8px;font-size:.9rem;box-sizing:border-box}
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="app" role="application">
    <div id="viewer3d">
      <div id="hud">tile: (0,0) ‚Ä¢ mode: centers ‚Ä¢ world: (0.00, 0.00)</div>
    </div>

    <div id="panel-container">
      <nav id="bottom-navbar">
        <button class="nav-btn active" data-panel="dashboard-panel">Dashboard</button>
        <button class="nav-btn" data-panel="grid-panel">Game Grid</button>
        <button class="nav-btn" data-panel="transform-panel">Transform</button>
        <button class="nav-btn" data-panel="mesh-panel">Meshes</button>
        <button class="nav-btn" data-panel="texture-panel">Textures</button>
        <button class="nav-btn" data-panel="tabs-panel">Tabs</button>
      </nav>

      <div id="panel-content">
        <div id="dashboard-panel" class="panel">
          <div class="button-group">
            <label id="load-model-btn" class="button" for="model-input">Load Model(s)</label>
            <button id="export-glb-btn" class="button" disabled>Export Active</button>
            <button id="copy-data-btn" class="button ghost" disabled>Copy Data</button>
            <button id="toggle-rig-btn" class="button ghost" disabled>Show Rig</button>
          </div>
          <div id="animation-controls-wrapper">
            <div id="animation-status" class="status-text">Load a model to begin.</div>
            <div id="animation-controls-ui" class="hidden">
              <div class="button-group">
                <button id="load-anim-btn" class="button ghost">Load Animation</button>
                <button id="remove-anim-btn" class="button accent" disabled>Remove Animation</button>
              </div>
              <div id="animation-timeline" class="hidden">
                <button id="play-pause-btn" class="button">‚ñ∂ Play</button>
                <div id="playback-controls" class="hidden">
                  <button id="rewind-btn" class="button ghost">‚àí0.5s</button>
                  <button id="forward-btn" class="button ghost">+0.5s</button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Game Grid -->
        <div id="grid-panel" class="panel hidden">
          <h3 style="margin-top:0">Game Grid</h3>
          <div class="form-row">
            <div class="form-group">
              <label>Tile Size (units)</label>
              <input id="grid-tile-size"  type="number" value="1" min="0.01" step="0.01">
            </div>
            <div class="form-group">
              <label>Chunk Size (tiles per side)</label>
              <input id="grid-chunk-size" type="number" value="50" min="1" step="1">
            </div>
            <div class="form-group">
              <label>Snap Mode</label>
              <select id="grid-snap-mode">
                <option value="centers" selected>Tile Centers (...,-24.5,-23.5,...)</option>
                <option value="edges">Tile Edges (...,-25,-24,-23,...)</option>
              </select>
            </div>
          </div>

          <div class="form-row">
            <div class="form-group">
              <label>Fit Footprint (tiles X)</label>
              <input id="fit-tiles-x" type="number" value="1" min="0.1" step="0.1">
            </div>
            <div class="form-group">
              <label>Fit Footprint (tiles Z)</label>
              <input id="fit-tiles-z" type="number" value="1" min="0.1" step="0.1">
            </div>
            <div class="form-group">
              <label>&nbsp;</label>
              <button id="fit-footprint-btn" class="button">Fit Active to Tiles</button>
            </div>
          </div>

          <div class="button-group">
            <button id="rebuild-grid-btn" class="button ghost">Rebuild Grid</button>
            <button id="snap-active-btn" class="button">Snap Active to Center Tile</button>
            <button id="place-at-cursor-btn" class="button">Place Active at Cursor</button>
            <button id="stick-ground-btn" class="button ghost">Stick Active to Ground (Y=0)</button>
          </div>

          <p class="status-text" style="padding-top:1rem">Grid-only view. 1 tile = 1 world unit. Centers are at half units like the game.</p>
        </div>

        <div id="transform-panel" class="panel hidden">
          <div id="transform-controls-wrapper">
            <div class="status-text">Select an active model to see transform controls.</div>
          </div>
        </div>

        <div id="mesh-panel" class="panel hidden">
          <div id="mesh-panel-content"></div>
        </div>

        <div id="texture-panel" class="panel hidden">
          <div id="texture-panel-content"></div>
        </div>

        <div id="tabs-panel" class="panel hidden">
          <div id="tabs-list"><div class="status-text">No models loaded.</div></div>
        </div>
      </div>
    </div>

    <div id="export-modal" class="modal-overlay hidden">
      <div class="modal-content">
        <div class="modal-header">Export Model</div>
        <div class="modal-body">
          <p>Select the model you wish to export. This will include all changes to its geometry, textures, and animations.</p>
          <div class="form-group">
            <label for="export-model-select">Model to Export:</label>
            <select id="export-model-select"></select>
          </div>
          <div class="form-group">
            <label for="export-filename-input">New Filename (.glb):</label>
            <input id="export-filename-input" type="text" placeholder="e.g., my_edited_model">
          </div>
        </div>
        <div class="modal-footer">
          <button id="cancel-export-btn" class="button ghost">Cancel</button>
          <button id="confirm-export-btn" class="button">Export</button>
        </div>
      </div>
    </div>

    <div id="bone-connect-modal" class="modal-overlay hidden">
      <div class="modal-content">
        <div class="modal-header">Connect Mesh to Bone</div>
        <div class="modal-body">
          <p>Parent the mesh <strong id="bone-connect-mesh-name"></strong> to a bone on another model's skeleton.</p>
          <div class="form-group">
            <label for="bone-connect-target-model">Target Model:</label>
            <select id="bone-connect-target-model"></select>
          </div>
          <div class="form-group">
            <label for="bone-connect-target-bone">Target Bone:</label>
            <select id="bone-connect-target-bone"></select>
          </div>
        </div>
        <div class="modal-footer">
          <button id="cancel-bone-connect-btn" class="button ghost">Cancel</button>
          <button id="confirm-bone-connect-btn" class="button">Connect</button>
        </div>
      </div>
    </div>

    <input type="file" id="model-input" accept=".glb,.gltf,model/gltf-binary,model/gltf+json" multiple class="visually-hidden-input" />
    <input type="file" id="animation-input" accept=".glb,.gltf" class="visually-hidden-input" />
    <input type="file" id="texture-input" accept="image/*" class="visually-hidden-input" />
  </div>

  <div id="dbg">
    <button class="button ghost" id="toggle-log">Logs</button>
  </div>
  <pre id="dbglog" class="hidden"></pre>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';
import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

/* ---------- Logger ---------- */
const logEl = document.getElementById('dbglog');
const log = (...a)=>{ const s=a.map(x=>typeof x==='string'?x:JSON.stringify(x)).join(' '); logEl.textContent += s + '\n'; logEl.scrollTop=logEl.scrollHeight; console.log(...a); };
window.addEventListener('error', e=>{ log('ERROR:', e.message || e); });
window.addEventListener('unhandledrejection', e=>{ log('REJECTION:', (e.reason && e.reason.message)||String(e.reason)); });
document.getElementById('toggle-log').addEventListener('click', ()=> logEl.classList.toggle('hidden'));

/* ---------- Grid config (MATCHES GAME) ---------- */
const GRID = {
  tile: 1,        // = TILE_SIZE in your game (1 unit per tile)
  chunk: 50,      // tiles per side (50√ó50 chunk)
  snapMode: 'centers' // centers at ..., -24.5, -23.5, ..., +24.5
};
const hud = document.getElementById('hud');

// centers => round((v - 0.5*t)/t)*t + 0.5*t
// edges   => round(v/t)*t
function snapCoord(v){
  const t = GRID.tile;
  const offset = GRID.snapMode === 'centers' ? (0.5 * t) : 0.0;
  return Math.round((v - offset)/t)*t + offset;
}
// Match game getTileAt(): off = TILES_PER_CHUNK/2 - 0.5
function tileIndexFromWorld(v){
  const off = GRID.chunk * 0.5 - 0.5; // 24.5 for 50√ó50
  return Math.round((v / GRID.tile) + off);
}
function updateHud(worldX, worldZ){
  const tx = tileIndexFromWorld(worldX);
  const tz = tileIndexFromWorld(worldZ);
  hud.textContent = `tile: (${tx},${tz}) ‚Ä¢ mode: ${GRID.snapMode} ‚Ä¢ world: (${worldX.toFixed(2)}, ${worldZ.toFixed(2)})`;
}

/* ---------- Global state ---------- */
let renderer, scene, camera, controls, pmremGen, envTex;
const clock = new THREE.Clock();
const gltfLoader = new GLTFLoader();
const draco = new DRACOLoader();
draco.setDecoderPath('https://unpkg.com/three@0.168.0/examples/jsm/libs/draco/');
gltfLoader.setDRACOLoader(draco);
gltfLoader.setMeshoptDecoder(MeshoptDecoder);
const textureLoader = new THREE.TextureLoader();

const models = {};
let activeModelId = null;
let modelIdCounter = 0;

let textureTarget = { mesh:null, type:null };
let meshToConnect = null;

/* Grid visuals (no terrain planes) */
let gridHelper = null;
let majorLines = null;
let cursorCross = null;

/* Raycasting to Y=0 plane */
const raycaster = new THREE.Raycaster();
const planeY0 = new THREE.Plane(new THREE.Vector3(0,1,0), 0);

/* ---------- DOM ---------- */
const viewerContainer = document.getElementById('viewer3d');
const modelInput = document.getElementById('model-input');
const animationInput = document.getElementById('animation-input');
const textureInput = document.getElementById('texture-input');

/* Grid panel controls */
const tileSizeInput = document.getElementById('grid-tile-size');
const chunkSizeInput = document.getElementById('grid-chunk-size');
const snapModeSelect = document.getElementById('grid-snap-mode');
const rebuildGridBtn = document.getElementById('rebuild-grid-btn');
const snapActiveBtn = document.getElementById('snap-active-btn');
const placeAtCursorBtn = document.getElementById('place-at-cursor-btn');
const stickGroundBtn = document.getElementById('stick-ground-btn');
const fitXInput = document.getElementById('fit-tiles-x');
const fitZInput = document.getElementById('fit-tiles-z');
const fitBtn = document.getElementById('fit-footprint-btn');

/* ---------- Init ---------- */
init();
updateAllPanels();
buildGameGrid();

/* ================== Core 3D Setup ================== */
function init() {
  scene = new THREE.Scene();
  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, preserveDrawingBuffer:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(viewerContainer.clientWidth || window.innerWidth, viewerContainer.clientHeight || Math.round(window.innerHeight*0.55));
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.setClearColor(0x101318, 1);
  viewerContainer.appendChild(renderer.domElement);

  camera = new THREE.PerspectiveCamera(50, renderer.domElement.clientWidth/renderer.domElement.clientHeight, 0.1, 5000);
  camera.position.set(0, 8, 12);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.target.set(0.5, 0, 0.5); // aim near the true center tile
  controls.enableDamping = true;
  controls.minDistance = 1;
  controls.maxDistance = 200;
  controls.maxPolarAngle = Math.PI * 0.499;

  pmremGen = new THREE.PMREMGenerator(renderer);
  envTex = pmremGen.fromScene(new RoomEnvironment(), 0.04).texture;
  scene.environment = envTex;
  scene.background = new THREE.Color(0x101318);

  const hemi = new THREE.HemisphereLight(0xffffff, 0x555555, 1.1);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff, 1.2);
  dir.position.set(-6, 10, 6);
  scene.add(dir);

  const axes = new THREE.AxesHelper(1.2);
  axes.position.set(0, 0.001, 0);
  scene.add(axes);

  setupEventListeners();
  animate();
}
function animate(){
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  Object.values(models).forEach(m => m.mixer && m.mixer.update(delta));
  controls.update();
  renderer.render(scene, camera);
}
function onWindowResize(){
  const w = viewerContainer.clientWidth || window.innerWidth;
  const h = viewerContainer.clientHeight || Math.round(window.innerHeight*0.55);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
}
new ResizeObserver(onWindowResize).observe(viewerContainer);
window.addEventListener('resize', onWindowResize);
renderer.getContext().canvas.addEventListener('webglcontextlost', (e)=>{ e.preventDefault(); log('WebGL context lost'); });

/* ================== Grid drawing (no terrain) ================== */
function clearGrid(){
  [gridHelper, majorLines, cursorCross].forEach(obj => obj && scene.remove(obj));
  gridHelper = majorLines = cursorCross = null;
}
function buildGameGrid(){
  clearGrid();

  const size = GRID.chunk * GRID.tile;     // 50 * 1 = 50 world units (one game chunk)
  const divisions = GRID.chunk;            // 50√ó50 tiles

  gridHelper = new THREE.GridHelper(size, divisions, 0x3a3f46, 0x2a2f36);
  gridHelper.material.transparent = true;
  gridHelper.material.opacity = 0.95;
  gridHelper.position.y = 0.0001; // tiny lift to avoid z-flicker with Y=0 items
  scene.add(gridHelper);

  // Major lines every 5 tiles
  const g = new THREE.BufferGeometry();
  const verts = [];
  const half = size * 0.5;
  const step = GRID.tile * 5;
  for (let x = -half; x <= half + 1e-6; x += step) verts.push(x,0.00015,-half, x,0.00015,half);
  for (let z = -half; z <= half + 1e-6; z += step) verts.push(-half,0.00015,z, half,0.00015,z);
  g.setAttribute('position', new THREE.Float32BufferAttribute(verts,3));
  majorLines = new THREE.LineSegments(
    g,
    new THREE.LineBasicMaterial({ color:0x55606c, transparent:true, opacity:0.9 })
  );
  scene.add(majorLines);

  // Cursor cross (snapped) ~ tile-sized
  const L = GRID.tile * 0.8;
  const crossG = new THREE.BufferGeometry();
  crossG.setAttribute('position', new THREE.Float32BufferAttribute([
    -L/2,0.001,0,  L/2,0.001,0,
     0,0.001,-L/2, 0,0.001,L/2
  ],3));
  cursorCross = new THREE.LineSegments(crossG, new THREE.LineBasicMaterial({ color:0xff4444 }));
  scene.add(cursorCross);
}

/* ================== Cursor snapping ================== */
renderer.domElement.addEventListener('pointermove', (e)=>{
  const ndc = new THREE.Vector2(
    (e.offsetX / renderer.domElement.clientWidth) * 2 - 1,
    -(e.offsetY / renderer.domElement.clientHeight) * 2 + 1
  );
  raycaster.setFromCamera(ndc, camera);
  const p = new THREE.Vector3();
  if (raycaster.ray.intersectPlane(planeY0, p)) {
    const snappedX = snapCoord(p.x);
    const snappedZ = snapCoord(p.z);
    if (cursorCross) cursorCross.position.set(snappedX, 0, snappedZ);
    updateHud(p.x, p.z);
  }
});

/* ================== Event listeners ================== */
function setupEventListeners() {
  document.getElementById('bottom-navbar').addEventListener('click', (e) => {
    if (e.target.matches('.nav-btn')) {
      const panelId = e.target.dataset.panel;
      document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
      e.target.classList.add('active');
      document.querySelectorAll('#panel-content .panel').forEach(p => p.classList.add('hidden'));
      document.getElementById(panelId).classList.remove('hidden');
    }
  });

  modelInput.addEventListener('change', handleModelLoad);
  animationInput.addEventListener('change', handleAnimationLoad);
  textureInput.addEventListener('change', handleTextureLoad);

  document.getElementById('export-glb-btn').addEventListener('click', openExportModal);
  document.getElementById('copy-data-btn').addEventListener('click', copyActiveModelData);
  document.getElementById('toggle-rig-btn').addEventListener('click', toggleRigVisibility);

  document.getElementById('load-anim-btn').addEventListener('click', () => animationInput.click());
  document.getElementById('remove-anim-btn').addEventListener('click', removeAnimation);
  document.getElementById('play-pause-btn').addEventListener('click', toggleAnimation);
  document.getElementById('rewind-btn').addEventListener('click', () => seekAnimation(-0.5));
  document.getElementById('forward-btn').addEventListener('click', () => seekAnimation(0.5));

  document.getElementById('cancel-export-btn').addEventListener('click', () => document.getElementById('export-modal').classList.add('hidden'));
  document.getElementById('confirm-export-btn').addEventListener('click', exportGLB);

  document.getElementById('bone-connect-target-model').addEventListener('change', populateBoneConnectBones);
  document.getElementById('cancel-bone-connect-btn').addEventListener('click', () => document.getElementById('bone-connect-modal').classList.add('hidden'));
  document.getElementById('confirm-bone-connect-btn').addEventListener('click', confirmBoneConnection);

  tileSizeInput.addEventListener('change', ()=>{
    GRID.tile = Math.max(0.01, parseFloat(tileSizeInput.value)||1);
    buildGameGrid();
  });
  chunkSizeInput.addEventListener('change', ()=>{
    GRID.chunk = Math.max(1, parseInt(chunkSizeInput.value)||50);
    buildGameGrid();
  });
  snapModeSelect.addEventListener('change', ()=>{ GRID.snapMode = snapModeSelect.value; });
  rebuildGridBtn.addEventListener('click', buildGameGrid);

  // Grid helpers
  snapActiveBtn.addEventListener('click', snapActiveToCenterTile);
  placeAtCursorBtn.addEventListener('click', placeActiveAtCursor);
  stickGroundBtn.addEventListener('click', stickActiveToGround);
  fitBtn.addEventListener('click', ()=>{
    const tx = Math.max(0.1, parseFloat(fitXInput.value)||1);
    const tz = Math.max(0.1, parseFloat(fitZInput.value)||1);
    fitActiveToTiles(tx, tz);
  });
}

/* ================== Model handling ================== */
function handleModelLoad(e){
  const files = e.target.files;
  if (!files.length) return;
  for (const file of files) {
    const reader = new FileReader();
    reader.onload = ev => {
      log('Parsing:', file.name, file.size + ' bytes');
      gltfLoader.parse(
        ev.target.result,
        '',
        (gltf) => {
          const id = `model-${modelIdCounter++}`;
          const stats = calculateModelStats(gltf.scene);
          const skeletonPresent = hasSkeleton(gltf.scene);

          let skeletonHelper = null;
          if (skeletonPresent) {
            skeletonHelper = new THREE.SkeletonHelper(gltf.scene);
            skeletonHelper.visible = false;
            scene.add(skeletonHelper);
          }

          gltf.scene.traverse(o=>{
            if (o.isMesh){
              o.castShadow = true;
              o.receiveShadow = true;
              if (!o.material.isMeshStandardMaterial){
                o.material = new THREE.MeshStandardMaterial({
                  color: (o.material?.color?.clone()) || new THREE.Color(0xffffff),
                  metalness: 0.1, roughness: 0.85
                });
              }
            }
          });

          models[id] = {
            gltf,
            mixer: skeletonPresent ? new THREE.AnimationMixer(gltf.scene) : null,
            animation: null,
            skeletonHelper,
            fileInfo: { name:file.name, size:file.size, polygons:stats.polygons, vertices:stats.vertices }
          };

          scene.add(gltf.scene);

          if (!activeModelId) {
            setActiveModel(id);
            frameObject(gltf.scene);
          }
          updateAllPanels();
          log('Loaded:', file.name, `P:${stats.polygons} V:${stats.vertices}`);
        },
        (error) => {
          log('GLTF parse error:', error?.message || error);
          alert(`Failed to load "${file.name}" (see Logs).`);
        }
      );
    };
    reader.readAsArrayBuffer(file);
  }
  modelInput.value = '';
}
function frameObject(object){
  const box = new THREE.Box3().setFromObject(object);
  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());
  const maxDim = Math.max(size.x, size.y, size.z);
  const dist = Math.max(4, maxDim * 2);

  controls.target.set(center.x || 0.5, 0, center.z || 0.5);
  camera.position.set(center.x + dist*0.35, dist*0.7, center.z + dist*0.9);
  camera.near = 0.01;
  camera.far = 5000;
  camera.updateProjectionMatrix();
  controls.update();
}

/* ================== Grid utilities for active model ================== */
function getActiveScene(){
  const m = models[activeModelId];
  return m?.gltf?.scene || null;
}
function snapActiveToCenterTile(){
  const s = getActiveScene(); if (!s) return;
  const c = 0.5 * GRID.tile; // 0.5 for TILE_SIZE=1
  s.position.set(c, s.position.y, c);
}
function placeActiveAtCursor(){
  const s = getActiveScene(); if (!s) return;
  const p = cursorCross ? cursorCross.position : new THREE.Vector3(0.5*GRID.tile,0,0.5*GRID.tile);
  s.position.set(p.x, s.position.y, p.z);
}
function stickActiveToGround(){
  const s = getActiveScene(); if (!s) return;
  const box = new THREE.Box3().setFromObject(s);
  const minY = box.min.y;
  s.position.y -= minY; // base to Y=0
}
function fitActiveToTiles(tilesX=1, tilesZ=1){
  const s = getActiveScene(); if (!s) return;
  const box = new THREE.Box3().setFromObject(s);
  const size = box.getSize(new THREE.Vector3());
  const targetX = tilesX * GRID.tile;
  const targetZ = tilesZ * GRID.tile;
  const scaleX = targetX / Math.max(1e-5, size.x);
  const scaleZ = targetZ / Math.max(1e-5, size.z);
  const k = Math.min(scaleX, scaleZ);
  s.scale.multiplyScalar(k);
}

/* ================== Panels ================== */
function updateAllPanels(){ updateDashboardPanel(); updateTransformPanel(); updateTabsPanel(); updateMeshPanel(); updateTexturePanel(); }

function updateDashboardPanel() {
  const statusText = document.getElementById('animation-status');
  const controlsUI = document.getElementById('animation-controls-ui');
  const animTimeline = document.getElementById('animation-timeline');
  const playbackControls = document.getElementById('playback-controls');
  const removeAnimBtn = document.getElementById('remove-anim-btn');
  const playPauseBtn = document.getElementById('play-pause-btn');
  const toggleRigBtn = document.getElementById('toggle-rig-btn');

  document.getElementById('export-glb-btn').disabled = !activeModelId;
  document.getElementById('copy-data-btn').disabled = !activeModelId;

  const model = models[activeModelId];
  if (!model) {
    statusText.textContent = 'Load a model to begin.';
    statusText.classList.remove('hidden');
    controlsUI.classList.add('hidden');
    toggleRigBtn.disabled = true;
    return;
  }

  if (model.skeletonHelper) {
    toggleRigBtn.disabled = false;
    toggleRigBtn.textContent = model.skeletonHelper.visible ? 'Hide Rig' : 'Show Rig';
  } else {
    toggleRigBtn.disabled = true;
  }

  controlsUI.classList.remove('hidden');
  statusText.classList.add('hidden');

  if (model.animation) {
    animTimeline.classList.remove('hidden');
    removeAnimBtn.disabled = false;
    const action = model.animation.action;
    if (action.isRunning()) {
      playPauseBtn.textContent = '‚ùö‚ùö Pause';
      playbackControls.classList.add('hidden');
    } else {
      playPauseBtn.textContent = '‚ñ∂ Play';
      playbackControls.classList.remove('hidden');
    }
  } else {
    animTimeline.classList.add('hidden');
    removeAnimBtn.disabled = true;
  }
}

let uniformBaselineScale = null; // captured when building the panel

function updateTransformPanel() {
  const wrapper = document.getElementById('transform-controls-wrapper');
  const model = models[activeModelId];

  if (!model) {
    wrapper.innerHTML = '<div class="status-text">Select an active model to see transform controls.</div>';
    return;
  }

  const s = model.gltf.scene;
  uniformBaselineScale = s.scale.clone(); // baseline for uniform scale factor

  const euler = new THREE.Euler().setFromQuaternion(s.quaternion, 'YXZ');

  const sliderRow = (id, label, value, min, max, step, decimals=2) => `
    <div class="slider-row" data-row="${id}" data-step="${step}" data-min="${min}" data-max="${max}" data-decimals="${decimals}">
      <label>${label}</label>
      <button class="nudge" data-dir="-1">‚àí</button>
      <input type="range" class="rng" value="${value}" min="${min}" max="${max}" step="${step}">
      <input type="number" class="num" value="${value}" step="${step}">
      <button class="nudge" data-dir="1">+</button>
    </div>`;

  wrapper.innerHTML = `
    <div class="transform-group">
      <h4>Position</h4>
      <div id="transform-pos">
        ${sliderRow('pos-x','X', s.position.x.toFixed(2), -250, 250, 0.01, 2)}
        ${sliderRow('pos-y','Y', s.position.y.toFixed(2), -50,  50,  0.01, 2)}
        ${sliderRow('pos-z','Z', s.position.z.toFixed(2), -250, 250, 0.01, 2)}
      </div>
      <div class="button-group" style="margin-top:.5rem;">
        <button id="snap-now-btn" class="button">Snap to Center Tile</button>
        <button id="stick-now-btn" class="button ghost">Stick to Ground</button>
      </div>
    </div>

    <div class="transform-group">
      <h4>Rotation (Degrees)</h4>
      <div id="transform-rot">
        ${sliderRow('rot-x','X', THREE.MathUtils.radToDeg(euler.x).toFixed(1), -180, 180, 0.5, 1)}
        ${sliderRow('rot-y','Y', THREE.MathUtils.radToDeg(euler.y).toFixed(1), -180, 180, 0.5, 1)}
        ${sliderRow('rot-z','Z', THREE.MathUtils.radToDeg(euler.z).toFixed(1), -180, 180, 0.5, 1)}
      </div>
    </div>

    <div class="transform-group">
      <h4>Scale (per-axis)</h4>
      <div id="transform-scale">
        ${sliderRow('scl-x','X', s.scale.x.toFixed(3), 0.01, 50, 0.001, 3)}
        ${sliderRow('scl-y','Y', s.scale.y.toFixed(3), 0.01, 50, 0.001, 3)}
        ${sliderRow('scl-z','Z', s.scale.z.toFixed(3), 0.01, 50, 0.001, 3)}
      </div>
    </div>

    <div class="transform-group">
      <h4>Uniform Scale (keeps shape)</h4>
      <div id="uniform-scale">
        ${sliderRow('uni','U', '1.00', 0.01, 50, 0.01, 2)}
        <div style="font-size:.85rem;color:var(--fg-light);margin-top:.25rem;">Factor √ó baseline (current shape). 1.00 = no change.</div>
      </div>
    </div>
  `;

  // Utility
  const clamp = (v,min,max)=>Math.min(max,Math.max(min,v));
  const setNumValue = (el,val,dec=2)=>{ el.value = Number(val).toFixed(dec); };

  // Bind all rows (pos/rot/scale/uni)
  wrapper.querySelectorAll('.slider-row').forEach(row=>{
    const rng = row.querySelector('.rng');
    const num = row.querySelector('.num');
    const id  = row.dataset.row;
    const step = parseFloat(row.dataset.step);
    const min = parseFloat(row.dataset.min);
    const max = parseFloat(row.dataset.max);
    const decimals = parseInt(row.dataset.decimals||2);

    const apply = (val)=>{
      val = clamp(val, min, max);
      rng.value = val;
      setNumValue(num, val, decimals);

      const scn = models[activeModelId]?.gltf.scene; if (!scn) return;

      if (id.startsWith('pos-')){
        const p = scn.position.clone();
        if (id==='pos-x') p.x = val; else if (id==='pos-y') p.y = val; else p.z = val;
        scn.position.copy(p);
      } else if (id.startsWith('rot-')){
        const cur = new THREE.Euler().setFromQuaternion(scn.quaternion, 'YXZ');
        const rx = id==='rot-x' ? THREE.MathUtils.degToRad(val) : cur.x;
        const ry = id==='rot-y' ? THREE.MathUtils.degToRad(val) : cur.y;
        const rz = id==='rot-z' ? THREE.MathUtils.degToRad(val) : cur.z;
        scn.quaternion.setFromEuler(new THREE.Euler(rx, ry, rz, 'YXZ'));
      } else if (id.startsWith('scl-')){
        const sc = scn.scale.clone();
        if (id==='scl-x') sc.x = val; else if (id==='scl-y') sc.y = val; else sc.z = val;
        scn.scale.copy(sc);
      } else if (id==='uni'){
        // Uniform factor relative to the captured baseline
        const f = val;
        const base = uniformBaselineScale || scn.scale.clone();
        scn.scale.set(base.x*f, base.y*f, base.z*f);
        // Also reflect new per-axis numbers in the other scale rows (for visual sync)
        const rows = wrapper.querySelectorAll('#transform-scale .slider-row');
        rows.forEach(r=>{
          const axis = r.dataset.row; // scl-x / scl-y / scl-z
          const axisChar = axis.slice(-1); // x,y,z
          const newVal = (axisChar==='x'?scn.scale.x:(axisChar==='y'?scn.scale.y:scn.scale.z));
          const rr = r.querySelector('.rng');
          const nn = r.querySelector('.num');
          rr.value = newVal;
          setNumValue(nn, newVal, 3);
        });
      }
    };

    // Range + number sync
    rng.addEventListener('input', ()=> apply(parseFloat(rng.value)));
    num.addEventListener('input', ()=> {
      const v = parseFloat(num.value);
      if (!isNaN(v)) apply(v);
    });

    // Nudges
    row.querySelectorAll('.nudge').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const dir = parseFloat(btn.dataset.dir);
        const cur = parseFloat(rng.value);
        apply(cur + dir*step);
      });
    });
  });

  // Snap & stick buttons
  wrapper.querySelector('#snap-now-btn').addEventListener('click', snapActiveToCenterTile);
  wrapper.querySelector('#stick-now-btn').addEventListener('click', stickActiveToGround);
}

function updateTabsPanel() {
  const container = document.getElementById('tabs-list');
  const ids = Object.keys(models);
  if (!ids.length) { container.innerHTML = '<div class="status-text">No models loaded.</div>'; return; }

  container.innerHTML = ids.map(id => {
    const m = models[id]; const {name,size,polygons,vertices} = m.fileInfo; const isActive = id===activeModelId;
    return `
      <div class="tab-card ${isActive?'active':''}" data-id="${id}">
        <div class="tab-card-header"><h3>${name}</h3></div>
        <div class="tab-card-info">
          <strong>Size:</strong><span>${formatBytes(size)}</span>
          <strong>Polygons:</strong><span>${polygons.toLocaleString()}</span>
          <strong>Vertices:</strong><span>${vertices.toLocaleString()}</span>
        </div>
        <div class="tab-card-actions">
          <button class="button activate-btn" ${isActive?'disabled':''}>Activate</button>
          <button class="button accent close-btn">Close</button>
        </div>
      </div>`;
  }).join('');

  container.querySelectorAll('.activate-btn').forEach(btn => btn.addEventListener('click', e => setActiveModel(e.target.closest('.tab-card').dataset.id)));
  container.querySelectorAll('.close-btn').forEach(btn => btn.addEventListener('click', e => removeModel(e.target.closest('.tab-card').dataset.id)));
}

function updateMeshPanel() {
  const container = document.getElementById('mesh-panel-content');
  const model = models[activeModelId];
  if (!model) { container.innerHTML = '<div class="status-text">Select an active model from the Tabs panel.</div>'; return; }

  const meshes = [];
  model.gltf.scene.traverse(obj => { if (obj.isMesh) meshes.push(obj); });

  container.innerHTML = `
    <div class="button-group" style="margin-bottom:1rem;">
      <button id="multi-delete-mesh-btn" class="button accent">Remove Selected</button>
    </div>
    <div id="mesh-list">
      ${meshes.map(mesh => `
        <div class="list-item" data-uuid="${mesh.uuid}">
          <input type="checkbox" class="mesh-select-checkbox">
          <span class="list-item-label">${mesh.name || '(no name)'}</span>
          <div class="list-item-actions">
            <button class="small-btn toggle-vis-btn" title="Toggle Visibility">${mesh.visible ? 'üëÅÔ∏è' : '‚ö™'}</button>
            <button class="small-btn rename-mesh-btn" title="Rename">‚úèÔ∏è</button>
            <button class="small-btn connect-bone-btn" title="Connect to Bone">üîó</button>
            <button class="small-btn delete-mesh-btn" title="Delete">üóëÔ∏è</button>
          </div>
        </div>
      `).join('')}
    </div>`;

  container.querySelectorAll('.toggle-vis-btn').forEach(btn => btn.addEventListener('click', e => toggleMeshVisibility(e.target.closest('.list-item').dataset.uuid)));
  container.querySelectorAll('.rename-mesh-btn').forEach(btn => btn.addEventListener('click', e => renameMesh(e.target.closest('.list-item').dataset.uuid)));
  container.querySelectorAll('.delete-mesh-btn').forEach(btn => btn.addEventListener('click', e => deleteMesh(e.target.closest('.list-item').dataset.uuid)));
  container.querySelectorAll('.connect-bone-btn').forEach(btn => btn.addEventListener('click', e => openBoneConnectModal(e.target.closest('.list-item').dataset.uuid)));
  document.getElementById('multi-delete-mesh-btn').addEventListener('click', deleteSelectedMeshes);
}

function updateTexturePanel() {
  const container = document.getElementById('texture-panel-content');
  const model = models[activeModelId];
  if (!model) { container.innerHTML = '<div class="status-text">Select an active model from the Tabs panel.</div>'; return; }

  const meshes = [];
  model.gltf.scene.traverse(obj => { if (obj.isMesh) meshes.push(obj); });

  const textureTypes = [
    { key: 'map', name: 'Albedo' }, { key: 'normalMap', name: 'Normal' },
    { key: 'metalnessMap', name: 'Metalness' }, { key: 'roughnessMap', name: 'Roughness' },
    { key: 'aoMap', name: 'AO' }, { key: 'emissiveMap', name: 'Emissive' }
  ];

  container.innerHTML = `
    <div class="form-group">
      <label for="texture-mesh-select">Target Mesh:</label>
      <select id="texture-mesh-select" ${!meshes.length ? 'disabled' : ''}>
        ${meshes.length ? meshes.map(m => `<option value="${m.uuid}">${m.name || m.uuid}</option>`).join('') : '<option>No meshes found in model</option>'}
      </select>
    </div>
    <div id="material-controls-wrapper"></div>
    <h4 style="margin-top: 1.5rem;">Texture Maps</h4>
    <div id="texture-grid">
      ${textureTypes.map(t => `<div class="texture-slot"><button class="button ghost upload-texture-btn" data-type="${t.key}">${t.name}</button></div>`).join('')}
    </div>`;
  
  const meshSelect = document.getElementById('texture-mesh-select');
  meshSelect.addEventListener('change', () => updateMaterialControls(scene.getObjectByProperty('uuid', meshSelect.value)));
  
  if (meshes.length) updateMaterialControls(scene.getObjectByProperty('uuid', meshSelect.value));
  else updateMaterialControls(null);

  container.querySelectorAll('.upload-texture-btn').forEach(btn => btn.addEventListener('click', e => {
    const meshUUID = document.getElementById('texture-mesh-select').value;
    const mesh = scene.getObjectByProperty('uuid', meshUUID);
    if (mesh) { textureTarget = { mesh, type: e.target.dataset.type }; textureInput.click(); }
    else { alert('Please select a valid mesh.'); }
  }));
}

function updateMaterialControls(mesh) {
  const wrapper = document.getElementById('material-controls-wrapper');
  if (!mesh || !mesh.material || !mesh.material.isMeshStandardMaterial) {
    wrapper.innerHTML = '<div class="status-text" style="padding:1rem 0; font-size: .9rem;">Selected mesh has no standard material properties to edit.</div>';
    return;
  }
  const mat = mesh.material;
  wrapper.innerHTML = `
  <div class="material-group">
    <h4>Material Properties</h4>
    <div class="slider-group-color" style="display:grid;grid-template-columns:1fr 1fr;gap:1rem;margin-bottom:.75rem;">
      <label for="mat-color">Base Color</label>
      <input type="color" id="mat-color" value="#${mat.color.getHexString()}">
    </div>
    <div class="slider-group-range" style="display:grid;grid-template-columns:100px 1fr 60px;gap:1rem;margin-bottom:.75rem;">
      <label for="mat-metalness">Metalness</label>
      <input type="range" id="mat-metalness" min="0" max="1" step="0.01" value="${mat.metalness}">
      <span id="mat-metalness-val">${mat.metalness.toFixed(2)}</span>
    </div>
    <div class="slider-group-range" style="display:grid;grid-template-columns:100px 1fr 60px;gap:1rem;margin-bottom:.75rem;">
      <label for="mat-roughness">Roughness</label>
      <input type="range" id="mat-roughness" min="0" max="1" step="0.01" value="${mat.roughness}">
      <span id="mat-roughness-val">${mat.roughness.toFixed(2)}</span>
    </div>
    <h4>Emissive</h4>
    <div class="slider-group-color" style="display:grid;grid-template-columns:1fr 1fr;gap:1rem;margin-bottom:.75rem;">
      <label for="mat-emissive">Color</label>
      <input type="color" id="mat-emissive" value="#${mat.emissive.getHexString()}">
    </div>
    <div class="slider-group-range" style="display:grid;grid-template-columns:100px 1fr 60px;gap:1rem;margin-bottom:.75rem;">
      <label for="mat-emissive-intensity">Intensity</label>
      <input type="range" id="mat-emissive-intensity" min="0" max="5" step="0.05" value="${mat.emissiveIntensity}">
      <span id="mat-emissive-intensity-val">${mat.emissiveIntensity.toFixed(2)}</span>
    </div>
  </div>`;
  wrapper.addEventListener('input', (e) => {
    const selectedMesh = scene.getObjectByProperty('uuid', document.getElementById('texture-mesh-select').value);
    if (!selectedMesh || !selectedMesh.material) return;
    const mat = selectedMesh.material;
    const target = e.target;
    switch (target.id) {
      case 'mat-color': mat.color.set(target.value); break;
      case 'mat-metalness': mat.metalness = parseFloat(target.value); document.getElementById('mat-metalness-val').textContent = mat.metalness.toFixed(2); break;
      case 'mat-roughness': mat.roughness = parseFloat(target.value); document.getElementById('mat-roughness-val').textContent = mat.roughness.toFixed(2); break;
      case 'mat-emissive': mat.emissive.set(target.value); break;
      case 'mat-emissive-intensity': mat.emissiveIntensity = parseFloat(target.value); document.getElementById('mat-emissive-intensity-val').textContent = mat.emissiveIntensity.toFixed(2); break;
    }
  });
}

/* ================== Misc Features ================== */
function copyActiveModelData() {
  const model = models[activeModelId]; if (!model) return;
  const { position, scale } = model.gltf.scene;
  const data = { position: position.toArray(), scale: scale.toArray() };
  navigator.clipboard.writeText(JSON.stringify(data, null, 2)).then(()=>alert('Model data copied.')).catch(()=>alert('Failed to copy.'));
}
function toggleRigVisibility() {
  const model = models[activeModelId];
  if (model && model.skeletonHelper) { model.skeletonHelper.visible = !model.skeletonHelper.visible; updateDashboardPanel(); }
}

/* --- Animation --- */
function handleAnimationLoad(e) {
  const file = e.target.files[0];
  const model = models[activeModelId];
  if (!file || !model || !model.mixer) { alert("Select an active model with a skeleton first."); return; }
  const reader = new FileReader();
  reader.onload = ev => {
    gltfLoader.parse(ev.target.result, '', (gltf) => {
      if (!gltf.animations.length) { alert('This file has no animations.'); return; }
      removeAnimation();
      const clip = gltf.animations[0];
      const action = model.mixer.clipAction(clip);
      model.animation = { clip, action };
      updateDashboardPanel();
    }, (err)=>{ log('Anim parse error:', err?.message || err); alert('Animation load failed.'); });
  };
  reader.readAsArrayBuffer(file);
  animationInput.value = '';
}
function removeAnimation(){ const m = models[activeModelId]; if (m && m.animation){ m.mixer.stopAllAction(); m.mixer.uncacheClip(m.animation.clip); m.animation = null; updateDashboardPanel(); } }
function toggleAnimation(){ const m = models[activeModelId]; if (!m || !m.animation) return; const a = m.animation.action; a.paused = !a.paused; if (!a.isRunning()) a.play(); updateDashboardPanel(); }
function seekAnimation(seconds){ const m = models[activeModelId]; if (!m || !m.animation) return; m.animation.action.time = Math.max(0, m.animation.action.time + seconds); m.mixer.update(0); }

/* --- Meshes --- */
function toggleMeshVisibility(uuid){ const mesh = scene.getObjectByProperty('uuid', uuid); if (mesh){ mesh.visible = !mesh.visible; updateMeshPanel(); } }
function renameMesh(uuid){ const mesh = scene.getObjectByProperty('uuid', uuid); if (mesh){ const nn = prompt("Enter new mesh name:", mesh.name); if (nn){ mesh.name = nn; updateMeshPanel(); updateTexturePanel(); } } }
function deleteMesh(uuid){ const mesh = scene.getObjectByProperty('uuid', uuid); if (mesh){ mesh.parent.remove(mesh); mesh.geometry?.dispose?.(); if (Array.isArray(mesh.material)) mesh.material.forEach(m=>m?.dispose?.()); else mesh.material?.dispose?.(); updateMeshPanel(); updateTexturePanel(); } }
function deleteSelectedMeshes(){ const checked = document.querySelectorAll('.mesh-select-checkbox:checked'); if (!checked.length) return alert("No meshes selected."); if (confirm(`Delete ${checked.length} mesh(es)?`)) checked.forEach(box=>deleteMesh(box.closest('.list-item').dataset.uuid)); }

/* --- Textures --- */
function handleTextureLoad(e) {
  const file = e.target.files[0]; if (!file || !textureTarget.mesh) return;
  const url = URL.createObjectURL(file);
  textureLoader.load(url, (texture) => {
    texture.colorSpace = THREE.SRGBColorSpace; texture.flipY = false;
    const { mesh, type } = textureTarget;
    if (!mesh.material || !mesh.material.isMeshStandardMaterial) { alert('Target mesh is not a standard material.'); URL.revokeObjectURL(url); return; }
    mesh.material[type] = texture; mesh.material.needsUpdate = true;
    alert(`Applied ${type}.`); URL.revokeObjectURL(url);
  });
  textureInput.value = '';
}

/* ---------- Utils ---------- */
function saveArrayBuffer(buffer, fileName) {
  const blob = new Blob([buffer], { type: 'model/gltf-binary' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = fileName;
  document.body.appendChild(link); link.click(); document.body.removeChild(link);
  URL.revokeObjectURL(link.href);
}
function formatBytes(bytes, decimals=2){ if(bytes===0) return '0 Bytes'; const k=1024; const dm=decimals<0?0:decimals; const sizes=['Bytes','KB','MB','GB']; const i=Math.floor(Math.log(bytes)/Math.log(k)); return parseFloat((bytes/Math.pow(k,i)).toFixed(dm))+' '+sizes[i]; }
function calculateModelStats(object){ let polygons=0, vertices=0; object.traverse(o=>{ if (o.isMesh && o.geometry && o.geometry.attributes?.position){ const g=o.geometry; polygons += g.index ? g.index.count/3 : g.attributes.position.count/3; vertices += g.attributes.position.count; } }); return {polygons, vertices}; }
function hasSkeleton(object){ let v=false; object.traverse(o=>{ if (o.isSkinnedMesh || o.isBone) v=true; }); return v; }
function removeModel(id) {
  const model = models[id];
  if (!model) return;
  scene.remove(model.gltf.scene);
  if (model.skeletonHelper) scene.remove(model.skeletonHelper);
  model.gltf.scene.traverse(obj => {
    if (obj.isMesh) {
      obj.geometry?.dispose?.();
      if (Array.isArray(obj.material)) obj.material.forEach(m => m?.dispose?.());
      else obj.material?.dispose?.();
    }
  });
  delete models[id];
  if (activeModelId === id) {
    const ids = Object.keys(models);
    setActiveModel(ids.length ? ids[0] : null);
  }
  updateAllPanels();
}
function setActiveModel(id) { activeModelId = id; updateAllPanels(); }
</script>
</body>
</html>