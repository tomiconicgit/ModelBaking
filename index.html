<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <title>GLB Animation Retargeter</title>

  <link rel="manifest" href='data:application/manifest+json,{
    "name":"GLB Animation Retargeter",
    "short_name":"GLB Retargeter",
    "start_url":".",
    "display":"standalone",
    "background_color":"#101318",
    "theme_color":"#101318",
    "icons":[
      {"src":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABS3GwHAAAAaklEQVR4nO3BMQEAAADCoPVPbQ0PoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACeDc1wAAGaT44gAAAAAElFTSuQmCC","sizes":"192x192","type":"image/png"}
    ]
  }' />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="GLB Retargeter" />
  <meta name="theme-color" content="#101318" />

  <style>
    :root {
      --bg:#101318; --panel-bg:#161a21;
      --fg:#e6eef6; --fg-light:#8899aa;
      --primary:#0099ff; --primary-light:#33aaff;
      --accent:#ff4757; --accent-light:#ff6b81;
      --border-color:#2a2f36;
      --viewer-height: 55vh;
    }
    html,body{height:100%;margin:0;overflow:hidden}
    body{
      background:var(--bg);color:var(--fg);
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
      -webkit-font-smoothing:antialiased;
    }
    #app{
      display:flex; flex-direction:column;
      height:100vh; height:100dvh; /* Dynamic viewport height */
      padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    #viewer3d{height:var(--viewer-height); flex-shrink:0;}
    #viewer3d canvas{display:block;width:100%;height:100%}
    #panel-container{
      flex-grow:1;
      background:var(--panel-bg);
      border-top:1px solid var(--border-color);
      display:flex; flex-direction:column;
      overflow:hidden;
    }
    .panel{
      display:flex; flex-direction:column;
      padding:1rem; height:100%;
    }
    .panel.hidden{display:none}
    .panel-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem;flex-shrink:0;gap:.5rem;flex-wrap:wrap}
    #mesh-list-container,#texture-options{overflow-y:auto;flex-grow:1}
    #status{text-align:center;color:var(--fg-light);padding:2rem 0}
    .button{
      background:var(--primary);color:#fff;border:none;border-radius:8px;
      padding:10px 16px;font-size:.9rem;font-weight:500;cursor:pointer;transition:background-color .2s;-webkit-tap-highlight-color:transparent;
    }
    .button:hover{background:var(--primary-light)}
    .button:disabled{background:#333;color:#777;cursor:not-allowed}
    .button.accent{background:var(--accent)} .button.accent:hover{background:var(--accent-light)}
    .button.ghost{background:transparent;border:1px solid var(--border-color);color:var(--fg)}
    .button.ghost:hover{background:var(--border-color)}
    #animation-controls { border-top: 1px solid var(--border-color); margin-top: 1rem; padding-top: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap; }
    #animation-status { font-size: 0.8rem; color: var(--fg-light); text-align: center; width: 100%; padding-bottom: 0.5rem;}
    
    /* --- Modal Styles --- */
    .modal-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.7); backdrop-filter: blur(4px);
      display: flex; align-items: center; justify-content: center;
      z-index: 1000;
    }
    .modal-overlay.hidden { display: none; }
    .modal-content {
      background: var(--panel-bg);
      border: 1px solid var(--border-color); border-radius: 12px;
      width: clamp(300px, 90vw, 600px); max-height: 85vh;
      display: flex; flex-direction: column;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }
    .modal-header { padding: 1rem; border-bottom: 1px solid var(--border-color); font-size: 1.2rem; }
    .modal-body { flex-grow: 1; overflow-y: auto; padding: 1rem; }
    .modal-footer { padding: 1rem; border-top: 1px solid var(--border-color); display: flex; justify-content: flex-end; gap: .5rem;}
    
    .bone-mapping-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        align-items: center;
    }
    .bone-mapping-grid > span {
        font-family: monospace;
        color: var(--fg-light);
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
    }
    .bone-mapping-grid select {
        width: 100%;
        background: #2a2f36;
        color: var(--fg);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        padding: 8px;
        font-size: 0.9rem;
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="app" role="application">
    <div id="viewer3d"></div>

    <div id="panel-container">
        <div id="main-panel" class="panel">
          <div class="panel-header">
            <button id="load-model-btn" class="button">Load RPM Model</button>
            <div style="display:flex;gap:.5rem;flex-wrap:wrap">
              <button id="tpose-btn" class="button ghost" disabled>T-Pose</button>
              <button id="export-glb-btn" class="button" disabled>Export GLB</button>
            </div>
          </div>

          <div id="animation-controls">
             <div id="animation-status">Load a model and an animation.</div>
             <button id="load-anim-btn" class="button ghost" disabled>Load Animation</button>
             <button id="retarget-btn" class="button" disabled>Retarget</button>
             <button id="play-anim-btn" class="button accent" disabled>Play Animation</button>
          </div>

          <div id="mesh-list-container">
            <div id="status">Load a GLB model to begin.</div>
          </div>
        </div>
        </div>

    <div id="retarget-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <div class="modal-header">Manual Bone Retargeting</div>
            <div class="modal-body">
                <div class="bone-mapping-grid" style="padding-bottom: 8px; font-weight: bold;">
                    <span>Mixamo Bone</span>
                    <span>RPM Target Bone</span>
                </div>
                <div id="bone-mapping-list" class="bone-mapping-grid">
                    </div>
            </div>
            <div class="modal-footer">
                <button id="cancel-retarget-btn" class="button ghost">Cancel</button>
                <button id="confirm-retarget-btn" class="button">Apply Retarget</button>
            </div>
        </div>
    </div>

    <input type="file" id="model-input" accept=".glb" style="display:none" />
    <input type="file" id="animation-input" accept=".glb" style="display:none" />
  </div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

// --- Global State ---
let renderer, scene, camera, controls;
let loadedGltf = null;
let mixer = null;
let loadedAnimation = null;
let retargetedClip = null;
const clock = new THREE.Clock();
const gltfLoader = new GLTFLoader();

// --- DOM ---
const viewerContainer = document.getElementById('viewer3d');
const loadBtn = document.getElementById('load-model-btn');
const exportBtn = document.getElementById('export-glb-btn');
const tposeBtn = document.getElementById('tpose-btn');
const modelInput = document.getElementById('model-input');
const meshListContainer = document.getElementById('mesh-list-container');
// Animation DOM
const animationInput = document.getElementById('animation-input');
const loadAnimationBtn = document.getElementById('load-anim-btn');
const retargetBtn = document.getElementById('retarget-btn');
const playAnimationBtn = document.getElementById('play-anim-btn');
const animationStatus = document.getElementById('animation-status');
// Modal DOM
const retargetModal = document.getElementById('retarget-modal');
const boneMappingList = document.getElementById('bone-mapping-list');
const confirmRetargetBtn = document.getElementById('confirm-retarget-btn');
const cancelRetargetBtn = document.getElementById('cancel-retarget-btn');

// --- Boot ---
init();

// ================== Core ==================
function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x222222);

  camera = new THREE.PerspectiveCamera(50, viewerContainer.clientWidth / viewerContainer.clientHeight, 0.1, 1000);
  camera.position.set(0, 1, 3);

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  viewerContainer.appendChild(renderer.domElement);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.target.set(0, 0.8, 0);
  controls.enableDamping = true;

  scene.add(new THREE.HemisphereLight(0xffffff, 0x8d8d8d, 3));
  const dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
  dirLight.position.set(5, 5, 5);
  scene.add(dirLight);

  scene.add(new THREE.GridHelper(20, 20, 0xcccccc, 0x777777));

  setupEventListeners();
  animate();
}

function animate(){
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  if (mixer) mixer.update(delta);
  controls.update();
  renderer.render(scene,camera);
}

function onWindowResize(){
    camera.aspect = viewerContainer.clientWidth / viewerContainer.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);
}

function setupEventListeners() {
  window.addEventListener('resize', onWindowResize);
  loadBtn.addEventListener('click', () => modelInput.click());
  modelInput.addEventListener('change', handleModelLoad);
  exportBtn.addEventListener('click', () => alert("Export not implemented in this version."));
  tposeBtn.addEventListener('click', setTPose);
  
  // Animation Listeners
  loadAnimationBtn.addEventListener('click', () => animationInput.click());
  animationInput.addEventListener('change', handleAnimationLoad);
  retargetBtn.addEventListener('click', showRetargetModal);
  playAnimationBtn.addEventListener('click', playRetargetedAnimation);

  // Modal Listeners
  confirmRetargetBtn.addEventListener('click', applyManualRetarget);
  cancelRetargetBtn.addEventListener('click', () => retargetModal.classList.add('hidden'));
}

function handleModelLoad(e){
  const file = e.target.files[0]; if(!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    gltfLoader.parse(ev.target.result,'', (gltf)=>{
      resetScene();
      loadedGltf = gltf;
      scene.add(gltf.scene);

      mixer = new THREE.AnimationMixer(gltf.scene);

      const box = new THREE.Box3().setFromObject(gltf.scene);
      const size = box.getSize(new THREE.Vector3()).length();
      const center = box.getCenter(new THREE.Vector3());

      controls.reset();
      controls.target.copy(center);
      camera.position.copy(center);
      camera.position.x += size / 1.5;
      camera.position.y += size / 2.0;
      camera.position.z += size / 1.5;
      camera.lookAt(center);
      camera.updateProjectionMatrix();
      
      exportBtn.disabled = false;
      tposeBtn.disabled = false;
      loadAnimationBtn.disabled = false;
      animationStatus.textContent = 'Model loaded. Now load a Mixamo animation.';
    }, (err)=>{
      console.error('GLTF parse error:', err);
    });
  };
  reader.readAsArrayBuffer(file);
  modelInput.value = '';
}

function resetScene(){
  if (loadedGltf) {
    scene.remove(loadedGltf.scene);
    // Proper disposal would go here
  }
  loadedGltf = null; mixer = null; loadedAnimation = null; retargetedClip = null;
  meshListContainer.innerHTML = `<div id="status">Load a GLB model to begin.</div>`;
  exportBtn.disabled = true; tposeBtn.disabled = true;
  loadAnimationBtn.disabled = true;
  retargetBtn.disabled = true;
  playAnimationBtn.disabled = true;
  animationStatus.textContent = 'Load a model and an animation.';
}

// ================== Animation & Retargeting ==================
const MIXAMO_TO_RPM_MAP = {
    'mixamorigHips': 'Hips', 'mixamorigSpine': 'Spine', 'mixamorigSpine1': 'Spine1', 'mixamorigSpine2': 'Spine2', 'mixamorigNeck': 'Neck', 'mixamorigHead': 'Head', 'mixamorigLeftShoulder': 'LeftShoulder', 'mixamorigLeftArm': 'LeftArm', 'mixamorigLeftForeArm': 'LeftForeArm', 'mixamorigLeftHand': 'LeftHand', 'mixamorigLeftHandThumb1': 'LeftHandThumb1', 'mixamorigLeftHandThumb2': 'LeftHandThumb2', 'mixamorigLeftHandThumb3': 'LeftHandThumb3', 'mixamorigLeftHandIndex1': 'LeftHandIndex1', 'mixamorigLeftHandIndex2': 'LeftHandIndex2', 'mixamorigLeftHandIndex3': 'LeftHandIndex3', 'mixamorigLeftHandMiddle1': 'LeftHandMiddle1', 'mixamorigLeftHandMiddle2': 'LeftHandMiddle2', 'mixamorigLeftHandMiddle3': 'LeftHandMiddle3', 'mixamorigLeftHandRing1': 'LeftHandRing1', 'mixamorigLeftHandRing2': 'LeftHandRing2', 'mixamorigLeftHandRing3': 'LeftHandRing3', 'mixamorigLeftHandPinky1': 'LeftHandPinky1', 'mixamorigLeftHandPinky2': 'LeftHandPinky2', 'mixamorigLeftHandPinky3': 'LeftHandPinky3', 'mixamorigRightShoulder': 'RightShoulder', 'mixamorigRightArm': 'RightArm', 'mixamorigRightForeArm': 'RightForeArm', 'mixamorigRightHand': 'RightHand', 'mixamorigRightHandThumb1': 'RightHandThumb1', 'mixamorigRightHandThumb2': 'RightHandThumb2', 'mixamorigRightHandThumb3': 'RightHandThumb3', 'mixamorigRightHandIndex1': 'RightHandIndex1', 'mixamorigRightHandIndex2': 'RightHandIndex2', 'mixamorigRightHandIndex3': 'RightHandIndex3', 'mixamorigRightHandMiddle1': 'RightHandMiddle1', 'mixamorigRightHandMiddle2': 'RightHandMiddle2', 'mixamorigRightHandMiddle3': 'RightHandMiddle3', 'mixamorigRightHandRing1': 'RightHandRing1', 'mixamorigRightHandRing2': 'RightHandRing2', 'mixamorigRightHandRing3': 'RightHandRing3', 'mixamorigRightHandPinky1': 'RightHandPinky1', 'mixamorigRightHandPinky2': 'RightHandPinky2', 'mixamorigRightHandPinky3': 'RightHandPinky3', 'mixamorigLeftUpLeg': 'LeftUpLeg', 'mixamorigLeftLeg': 'LeftLeg', 'mixamorigLeftFoot': 'LeftFoot', 'mixamorigLeftToeBase': 'LeftToeBase', 'mixamorigRightUpLeg': 'RightUpLeg', 'mixamorigRightLeg': 'RightLeg', 'mixamorigRightFoot': 'RightFoot', 'mixamorigRightToeBase': 'RightToeBase'
};

function handleAnimationLoad(e){
    const file = e.target.files[0]; if(!file) return;
    const reader = new FileReader();
    reader.onload = ev => {
        gltfLoader.parse(ev.target.result, '', (gltf) => {
            if (gltf.animations && gltf.animations.length) {
                loadedAnimation = gltf.animations[0];
                retargetBtn.disabled = false;
                playAnimationBtn.disabled = true;
                animationStatus.textContent = `Animation "${loadedAnimation.name || file.name}" loaded. Ready to retarget.`;
            } else {
                alert('This GLB file contains no animations.');
            }
        });
    };
    reader.readAsArrayBuffer(file);
    animationInput.value = '';
}

function showRetargetModal() {
    if (!loadedGltf || !loadedAnimation) {
        alert("Please load a model and an animation first.");
        return;
    }

    // 1. Get bones from Mixamo animation
    const mixamoBones = new Set();
    loadedAnimation.tracks.forEach(track => mixamoBones.add(track.name.split('.')[0]));

    // 2. Get bones from RPM model's skeleton
    const rpmBones = [];
    loadedGltf.scene.traverse(obj => {
        if (obj.isSkinnedMesh && rpmBones.length === 0) {
           obj.skeleton.bones.forEach(bone => rpmBones.push(bone.name));
        }
    });
     if (rpmBones.length === 0) {
        alert("Could not find a skeleton in the loaded model.");
        return;
    }

    // 3. Populate the modal UI
    boneMappingList.innerHTML = '';
    const rpmOptionsHTML = rpmBones.map(name => `<option value="${name}">${name}</option>`).join('');
    
    [...mixamoBones].sort().forEach(mixamoBone => {
        const suggestedRpmBone = MIXAMO_TO_RPM_MAP[mixamoBone];
        
        const span = document.createElement('span');
        span.textContent = mixamoBone;
        
        const select = document.createElement('select');
        select.dataset.mixamoBone = mixamoBone;
        select.innerHTML = `<option value="">--Ignore--</option>${rpmOptionsHTML}`;
        
        if (suggestedRpmBone && rpmBones.includes(suggestedRpmBone)) {
            select.value = suggestedRpmBone;
        }

        boneMappingList.appendChild(span);
        boneMappingList.appendChild(select);
    });

    retargetModal.classList.remove('hidden');
}

function applyManualRetarget() {
    const manualMap = {};
    const selects = boneMappingList.querySelectorAll('select');
    selects.forEach(select => {
        if (select.value) { // Only map if a target is selected
            manualMap[select.dataset.mixamoBone] = select.value;
        }
    });

    const newTracks = [];
    loadedAnimation.tracks.forEach(track => {
        const parts = track.name.split('.');
        const mixamoBoneName = parts[0];
        const property = parts[1];

        const rpmBoneName = manualMap[mixamoBoneName];
        if (rpmBoneName) {
            const newTrack = track.clone();
            newTrack.name = `${rpmBoneName}.${property}`;
            newTracks.push(newTrack);
        }
    });

    if (newTracks.length === 0) {
        alert("Retargeting failed. No bones were mapped.");
        return;
    }

    retargetedClip = new THREE.AnimationClip('retargeted_animation', -1, newTracks);
    playAnimationBtn.disabled = false;
    animationStatus.textContent = 'Retargeting complete! Ready to play.';
    retargetModal.classList.add('hidden');
    alert("Animation retargeted successfully!");
}

function playRetargetedAnimation() {
    if (!mixer || !retargetedClip) {
        alert("No retargeted animation available to play.");
        return;
    }
    mixer.stopAllAction();
    const action = mixer.clipAction(retargetedClip);
    action.setLoop(THREE.LoopRepeat, Infinity).play();
    animationStatus.textContent = `Playing "${retargetedClip.name}" in a loop.`;
}

function setTPose() {
  if (!loadedGltf) return;
  if (mixer) mixer.stopAllAction();
  loadedGltf.scene.traverse(obj => {
    if (obj.isSkinnedMesh) obj.skeleton.pose();
  });
}

</script>
</body>
</html>
